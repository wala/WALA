plugins {
	id 'eclipse'
}

eclipse {
	project.natures 'org.eclipse.pde.PluginNature'
	classpath.file.whenMerged {
		entries.each {
			if (it.path == 'src/testSubjects/java') {
				it.entryAttributes['ignore_optional_problems'] = true
			}
		}
	}
}

sourceSets {
	testSubjects
}

final Provider<JavaCompile> compileTestSubjectsJava = tasks.named('compileTestSubjectsJava', JavaCompile)

if (javaCompiler == 'ecj') {
	compileTestSubjectsJava.configure {
		options.compilerArgs << '-err:none'
		options.compilerArgs << '-warn:none'
	}
}

dependencies {
	api(project(':com.ibm.wala.shrike')) {
		because 'public class Entrypoint implements interface BytecodeConstraints'
	}
	api(project(':com.ibm.wala.util')) {
		because 'public interface CallGraph extends interface NumberedGraph'
	}
	testFixturesImplementation(
			'junit:junit:4.13',
			'org.apache.ant:ant:1.10.7',
	)
	testImplementation(
			'junit:junit:4.13',
			'org.hamcrest:hamcrest-core:2.2',
	)
	testRuntimeOnly(
			files(compileTestSubjectsJava.map { it.outputs.files.first() })
	)
}

tasks.named('javadoc') {
	classpath += files project(':com.ibm.wala.dalvik').tasks.named('compileJava', JavaCompile)
}


////////////////////////////////////////////////////////////////////////
//
//  download and extract kawa 3.0 "kawa.jar"
//

final downloadKawa = tasks.register('downloadKawa', VerifiedDownload) {
	ext.version = '3.0'
	final archive = "kawa-${version}.zip"
	src "https://ftp.gnu.org/pub/gnu/kawa/$archive"
	dest "$temporaryDir/$archive"
	checksum '2713e6dfb939274ba3b1d36daea68436'
}

tasks.register('extractKawa') {
	inputs.files downloadKawa
	outputs.file layout.buildDirectory.file("$name/kawa.jar")

	doLast {
		copy {
			from(downloadKawa.map { zipTree it.dest }) {
				include "kawa-${downloadKawa.get().version}/lib/${outputs.files.singleFile.name}"
				eachFile {
					relativePath RelativePath.parse(!directory, relativePath.lastName)
				}
			}
			into outputs.files.singleFile.parent
			includeEmptyDirs false
		}
	}
}


////////////////////////////////////////////////////////////////////////
//
//  specialized task for Kawa compilation into jar archive
//

@CacheableTask
class CompileKawaJar extends Jar {

	@Nested
	final compile = project.tasks.register("compileKawaInto${name.capitalize()}", JavaExec) {
		classpath project.tasks.named('extractKawa')
		main 'kawa.repl'

		args '-d', temporaryDir
		outputs.dir temporaryDir

		logging.captureStandardError LogLevel.INFO
		args '--main', '-C', schemeFile.get()
		inputs.file schemeFile
	}

	CompileKawaJar() {
		from compile
		archiveVersion.set null
		destinationDirectory.set project.layout.buildDirectory.dir(name)
	}

	final RegularFileProperty schemeFile = project.objects.fileProperty()

	void setBaseName(String name) {
		archiveFileName.set "${name}.jar"
	}

}


////////////////////////////////////////////////////////////////////////
//
//  download, unpack, and build kawa chess
//

final kawaChessCommitHash = 'f1d2dcc707a1ef19dc159e2eaee5aecc8a41d7a8'

final downloadKawaChess = tasks.register('downloadKawaChess', VerifiedDownload) {
	src "https://github.com/ttu-fpclub/kawa-chess/archive/${kawaChessCommitHash}.zip"
	dest "$temporaryDir/kawa-chess.zip"
	checksum 'cf29613d2be5f476a475ee28b4df9d9e'
}

final unpackKawaChess = tasks.register('unpackKawaChess') {
	inputs.files downloadKawaChess
	outputs.dir "$temporaryDir/kawa-chess-$kawaChessCommitHash"

	doLast {
		copy {
			from zipTree(inputs.files.singleFile)
			into outputs.files.singleFile.parent
		}
	}
}

tasks.register('buildChessJar', CompileKawaJar) {
	final mainScheme = unpackKawaChess.map { file("$it.outputs.files.singleFile/main.scm") }
	schemeFile.fileProvider mainScheme
	inputs.files unpackKawaChess
	baseName 'kawachess'
}


////////////////////////////////////////////////////////////////////////
//
//  build the kawa test jar
//

tasks.register('buildKawaTestJar', CompileKawaJar) {
	final testScheme = file('kawasrc/test.scm')
	schemeFile.fileValue testScheme
	baseName 'kawatest'
}


////////////////////////////////////////////////////////////////////////
//
//  download and extract "bcel-5.2.jar"
//

final downloadBcel = tasks.register('downloadBcel', VerifiedDownload) {
	ext.basename = 'bcel-5.2'
	final archive = "${basename}.tar.gz"
	src "http://archive.apache.org/dist/jakarta/bcel/binaries/$archive"
	dest "$temporaryDir/$archive"
	checksum '19bffd7f217b0eae415f1ef87af2f0bc'
	useETag false
}

tasks.register('extractBcel') {
	final basename = downloadBcel.map { it.basename }
	final jarFile = basename.flatMap { layout.buildDirectory.file "$name/${it}.jar" }
	inputs.files downloadBcel
	outputs.file jarFile

	doLast {
		copy {
			from(tarTree(inputs.files.singleFile)) {
				include "${basename.get()}/${basename.get()}.jar"
				eachFile {
					relativePath RelativePath.parse(!directory, relativePath.lastName)
				}
			}
			into jarFile.get().asFile.parent
			includeEmptyDirs false
		}
	}
}


////////////////////////////////////////////////////////////////////////
//
//  download "java-cup-11a.jar"
//

tasks.register('downloadJavaCup', VerifiedDownload) {
	def archive = 'java-cup-11a.jar'
	src "http://www2.cs.tum.edu/projects/cup/$archive"
	dest layout.buildDirectory.file("$name/$archive")
	checksum '2bda8c40abd0cbc295d3038643d6e4ec'
}


////////////////////////////////////////////////////////////////////////
//
//  collect "JLex.jar"
//

tasks.register('collectJLex', Jar) {
	from project(':com.ibm.wala.cast.java.test.data').compileTestJava
	include 'JLex/'
	archiveFileName = 'JLex.jar'
	destinationDirectory = layout.buildDirectory.dir name
}


////////////////////////////////////////////////////////////////////////
//
//  generate "hello_hash.jar"
//

final downloadOcamlJava = tasks.register('downloadOcamlJava', VerifiedDownload) {
	def version = '2.0-alpha1'
	ext.basename = "ocamljava-$version"
	def archive = "${basename}.tar.gz"
	src "http://www.ocamljava.org/downloads/download.php?version=$version-bin"
	dest "$temporaryDir/$archive"
	checksum '45feec6e3889f5073a39c2c4c84878d1'
}

final unpackOcamlJava = tasks.register('unpackOcamlJava', Sync) {
	from downloadOcamlJava.map { tarTree it.dest }
	into temporaryDir
}

final prepareGenerateHelloHashJar = tasks.register('prepareGenerateHelloHashJar', Copy) {
	from 'ocaml/hello_hash.ml'
	into temporaryDir
	ext.copiedOcamlSource = file("$temporaryDir/$source.singleFile.name")
}

final generateHelloHashJar = tasks.register('generateHelloHashJar', JavaExec) {
	final ocamlSource = prepareGenerateHelloHashJar.map { it.copiedOcamlSource }
	inputs.file ocamlSource

	def jarTarget = layout.projectDirectory.file('ocaml/hello_hash.jar')
	outputs.file jarTarget
	outputs.cacheIf { true }

	final downloadOcamlJavaBasename = downloadOcamlJava.map { it.basename }
	it.inputs.property 'downloadOcamlJavaBasename', downloadOcamlJavaBasename

	final ocamlJavaJar = unpackOcamlJava.map {
		file "$it.destinationDir/${downloadOcamlJavaBasename.get()}/lib/ocamljava.jar"
	}
	inputs.file ocamlJavaJar
	classpath ocamlJavaJar

	main 'ocaml.compilers.ocamljavaMain'
	args '-o', jarTarget
	argumentProviders.add({ ->
		[ocamlSource.get().toString()]
	} as CommandLineArgumentProvider)
}


////////////////////////////////////////////////////////////////////////
//
//  collect "com.ibm.wala.core.testdata_1.0.0.jar"
//

tasks.register('collectTestData', Jar) {
	archiveFileName.set 'com.ibm.wala.core.testdata_1.0.0.jar'
	from compileTestSubjectsJava
	from 'classes'
	includeEmptyDirs false
	destinationDirectory = layout.buildDirectory.dir name
}


////////////////////////////////////////////////////////////////////////
//
//  collect "com.ibm.wala.core.testdata_1.0.0a.jar"
//

tasks.register('collectTestDataA', Jar) {
	archiveFileName.set 'com.ibm.wala.core.testdata_1.0.0a.jar'
	from compileTestSubjectsJava
	from 'classes'
	includeEmptyDirs false
	destinationDirectory = layout.buildDirectory.dir name
	exclude(
			'**/CodeDeleted.class',
			'**/SortingExample.class',
			'**/A.class',
	)
}


////////////////////////////////////////////////////////////////////////


tasks.named('processTestResources') {
	[
			'buildChessJar',
			'buildKawaTestJar',
			'collectJLex',
			'collectTestData',
			'downloadJavaCup',
			'extractBcel',
			'extractKawa',
	].each {
		from tasks.named(it)
	}

	// If "ocaml/hello_hash.jar" exists, then treat it as up-to-date and ready to use.  But if it is
	// missing, then use the generateHelloHashJar task to rebuild it.  The latter will entail
	// downloading OCaml-Java if we haven't already: something we prefer to avoid.
	final helloHashJar = generateHelloHashJar.get().outputs.files.singleFile
	from helloHashJar.exists() ? helloHashJar : generateHelloHashJar
}

tasks.named('test') {
	maxHeapSize = '1500M'
	systemProperty 'com.ibm.wala.junit.analyzingJar', 'true'
	systemProperty 'com.ibm.wala.junit.profile', 'short'
	classpath += files project(':com.ibm.wala.core').sourceSets.test.java.outputDir
	testLogging {
		exceptionFormat = 'full'
		events 'passed', 'skipped', 'failed'
	}
	// temporarily turn off some tests on JDK 11+
	if (JavaVersion.current() >= JavaVersion.VERSION_11) {
		exclude '**/exceptionpruning/ExceptionAnalysisTest.class'
		exclude '**/exceptionpruning/ExceptionAnalysis2EdgeFilterTest.class'
		exclude '**/cha/LibraryVersionTest.class'
		exclude '**/ir/TypeAnnotationTest.class'
	}

	outputs.file layout.buildDirectory.file('report')
}

apply from: rootProject.file("gradle-mvn-push.gradle")
